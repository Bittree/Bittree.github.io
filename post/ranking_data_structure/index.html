<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="在大量级的情况下，排行榜利用数据库(redis/mysql等)提供的排序功能比较不好处理，需要手动采用内存排序，排序的数据结构和算法需要谨慎选择，以在节约内存的情况下达到高性能的目的。
  e.g: mysql实时排行，处理单个请求时，百万数据需要2s、千万数据需要1min左右，当存在多个并发请求时效率很难接受。
 前XXX名排行榜服务(TopN) 特点：
 读多写少 全量拉取 一般需要显示的前XXX名比较小，而且是提前定好限制的，比如前100名  方案：
 显示的排名比较少的情况下（前100、前1000等），可以简单地维护一个集合，在查询的时候逻辑做一遍排序；也可以维护一个有序的数据结构，在每次数据变化时去触发排序。对于大批量的查询请求，可以在不同节点做缓存，设置过期时间来定时拉取数据，查询时只返回缓存中的数据。 排名数量级比较大的情况下（10w、百万、亿级别等），需要考虑特定的排序数据结构，比如bst。  数据排名服务(“我”的排名) 问题：有M（M=100万）个人分数在0~N（N=100万）之间，分数变化比较频繁，要求找出分数为X的玩家的排名。  排序数据在实际情况下是离散的、有限的，可以映射到一定的范围内，最简单的是把[X&#43;1,N]的分数段的玩家数量相加，复杂度为O(M)。为了更快地求出某个玩家的排名，可以使用的有桶排序、线段树、统计树等数据结构。如果数据量比较小的话也可以采用redis的zset。
桶排序 比如统计学生分数，满分120分，使用两层桶排序，第一层桶从0到119编号：0号桶统计0分的学生人数、1号桶统计1分的学生人数、2号桶统计2分的学生人数&amp;hellip;第二层桶从0到19编号，每个桶统计第一层里的6个桶的总人数，比如第二层的0号桶统计第一层的0号桶到5号桶的总人数，第二层的1号桶统计第一层的6号桶到11号桶的总人数&amp;hellip;当我们查询65分的人的排名时，如果从第一层开始我们就要从119号桶加到66号桶，但是我们可以先用第二层桶的数据，第二层桶（119-65）/6=9 也就是第二层10~19号桶的数据相加，如果是要求考63分的学生的排名，那除了第二层10~19号桶，还要加上第一层的64~65号桶的数据。如果区间比较大，比如满分是1000分或者10000分，可以考虑多加几层桶来做索引，最后实际形成的是一个树形结构。
线段树 具体介绍可以看这里：OI WIKI 线段树。其实很简单，二叉搜索树的每个节点的值都是一个固定的数，线段树的每个节点都表示的是一个范围，父节点的范围等于左右子节点的范围连接起来。比如左孩子的是[0, 3],右孩子的是[4, 5], 那么父节点的应该是[0, 5]. 线段树的第一个应用场景是连续区间求和。线段树的查询比较简单，如果要查询的范围等于某一个节点的范围，直接返回这个节点的值，如果不等于则需要进行区间结点的拆分，将几个子区间的节点值加起来。但是当数据有更新的时候，不能把所有对应区间的节点都遍历和修改，只能用懒标记，就是把改动存在父节点，之后再查询的时候再把改动下沉到对应的子节点。如果只是更新一个玩家的变化的话比较方便，直接将原来的key-1，新的key&#43;1，需要两次查询修改操作，复杂度O(logN)。
线段树还有一个应用场景是求区间的最值，比如当前有8个网关，每个网关上连接的客户端不同，要求当前连接数最少的客户端。每个节点上需要存储这个节点的区间内连接数最少的网关的id和连接数，然后层层往上比较合并，根节点的是当前最少连接数的网关。当这个网关连接数增加的时候，需要更新对应的最小值，从根节点往下依次更新和比较，主要是一次查询&#43;一次向上更新到根节点，时间和层数有关，复杂度是O(logN)
树状数组 具体介绍可以看这里：OI WIKI 树状数组 比起线段树，树状数组是代码比较简单，但是思路更复杂一点，核心是使用lowbit方法来算出树中每个节点的范围，比如要看88号节点的管理范围：
括号后面是进制 88(10)=1011000(2) lowbit(88) = 8(10) = 1000(2) 所以88号节点管理的范围为8，即80~88 树状数组的一个特点是每一层节点是二进制表示中1和0的数量不一样，比如有8个节点，8(10)=1000(2),二进制有4位。它下一层有三个孩子4、6、7，4(10)=100(2),6(10)=110(2),7(10)=111(2),二进制表示都是3位，三个孩子的管理范围不重合，且4的二进制表示中有1个1，6的二进制表示中有2个1，7的二进制表示中有3个1，很有规律，而把这些串起来的方法就是lowbit：
1. x-lowbit(x): 同一层节点之间范围井水不犯河水，用x-lowbit(x)把自己的最低位1减掉可以横向跳到同一层相邻的比较小的节点，比如7-lowbit(7)=6, 6-lowbit(6)=4。所以区间求和(1~N)的时候可以用x-lowbit(x)来跳转节点并把节点值都加起来。如果区间不是从1开始的，比如是(M~N)，可以用sum(1~N)-sum(1~M)求得。 2. x&#43;lowbit(x): 孩子节点用x&#43;lowbit(x)等于父节点，所以单点修改的时候可以用x&#43;lowbit(x)从子节点开始不断向上修改父结点的值，加上修改的数据。 和线段树比起来，树状数组的代码更简洁，因为需要保存的中间状态更少，因为通过比较巧妙的结构和lowbit进行状态转移。但是也正是因为如此，树状数组这个结构更类似于知识点一样的结构，记得就记得，不记得的话也不好想起来，不像线段树原理比较简单清楚，知道大概的原理就能直接写。而且树状数组本质是维护前缀和，所以它的扩展性是不够的，不能用来处理最大/最小值，因为没有足够的区间信息。
可以说树状数组能做的事情其实是线段树的一个子集，大多数情况下使用树状数组真的只是因为它好写并且常数小而已。然而zkw线段树(https://zhuanlan.zhihu.com/p/29876526)可以抹掉这个问题，zkw线段树省去了自顶向下查找的过程，而是直接开成满二叉树，所以比N大的最小的2^k就是第一个叶子节点。代码很短也很好理解。  统计二叉树 统计二叉树的叶子节点上保存了以当前节点为根的子树的节点总数。插入删除时，只需要把路径上的每个节点保存的节点数量加减1即可。基于这个特性，它可以支持这样的操作：
 查找第N大的节点。从根节点开始向下找，当前节点值大于N则在左子树里面找，如果N大于左子树的值，则N减去左子树的值，然后再在右子树中找，等于则就是本节点。 查找某个节点的排名。从该节点往上，如果是右节点就加上左节点的节点值，一直到根节点。  既然是二叉树，为了性能就需要保持树是平衡的，可以考虑各种平衡树的姿势(有的语言自带平衡树的实现，比如cpp里stl的map和set就是红黑树实现的)，在其基础上在节点中加上统计树的特性就可以了。" />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="/post/ranking_data_structure/" />


    <title>
        
            排行榜的数据结构和分析 :: Future Primitive  — When it&#39;s time to return, you won&#39;t be looking in the mirror.
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.min.44b13a9b5c5c41f27a35f532b480557dbe9d446de4a77b14ceab08069da36783.css">




<meta itemprop="name" content="排行榜的数据结构和分析">
<meta itemprop="description" content="在大量级的情况下，排行榜利用数据库(redis/mysql等)提供的排序功能比较不好处理，需要手动采用内存排序，排序的数据结构和算法需要谨慎选择，以在节约内存的情况下达到高性能的目的。
  e.g: mysql实时排行，处理单个请求时，百万数据需要2s、千万数据需要1min左右，当存在多个并发请求时效率很难接受。
 前XXX名排行榜服务(TopN) 特点：
 读多写少 全量拉取 一般需要显示的前XXX名比较小，而且是提前定好限制的，比如前100名  方案：
 显示的排名比较少的情况下（前100、前1000等），可以简单地维护一个集合，在查询的时候逻辑做一遍排序；也可以维护一个有序的数据结构，在每次数据变化时去触发排序。对于大批量的查询请求，可以在不同节点做缓存，设置过期时间来定时拉取数据，查询时只返回缓存中的数据。 排名数量级比较大的情况下（10w、百万、亿级别等），需要考虑特定的排序数据结构，比如bst。  数据排名服务(“我”的排名) 问题：有M（M=100万）个人分数在0~N（N=100万）之间，分数变化比较频繁，要求找出分数为X的玩家的排名。  排序数据在实际情况下是离散的、有限的，可以映射到一定的范围内，最简单的是把[X&#43;1,N]的分数段的玩家数量相加，复杂度为O(M)。为了更快地求出某个玩家的排名，可以使用的有桶排序、线段树、统计树等数据结构。如果数据量比较小的话也可以采用redis的zset。
桶排序 比如统计学生分数，满分120分，使用两层桶排序，第一层桶从0到119编号：0号桶统计0分的学生人数、1号桶统计1分的学生人数、2号桶统计2分的学生人数&hellip;第二层桶从0到19编号，每个桶统计第一层里的6个桶的总人数，比如第二层的0号桶统计第一层的0号桶到5号桶的总人数，第二层的1号桶统计第一层的6号桶到11号桶的总人数&hellip;当我们查询65分的人的排名时，如果从第一层开始我们就要从119号桶加到66号桶，但是我们可以先用第二层桶的数据，第二层桶（119-65）/6=9 也就是第二层10~19号桶的数据相加，如果是要求考63分的学生的排名，那除了第二层10~19号桶，还要加上第一层的64~65号桶的数据。如果区间比较大，比如满分是1000分或者10000分，可以考虑多加几层桶来做索引，最后实际形成的是一个树形结构。
线段树 具体介绍可以看这里：OI WIKI 线段树。其实很简单，二叉搜索树的每个节点的值都是一个固定的数，线段树的每个节点都表示的是一个范围，父节点的范围等于左右子节点的范围连接起来。比如左孩子的是[0, 3],右孩子的是[4, 5], 那么父节点的应该是[0, 5]. 线段树的第一个应用场景是连续区间求和。线段树的查询比较简单，如果要查询的范围等于某一个节点的范围，直接返回这个节点的值，如果不等于则需要进行区间结点的拆分，将几个子区间的节点值加起来。但是当数据有更新的时候，不能把所有对应区间的节点都遍历和修改，只能用懒标记，就是把改动存在父节点，之后再查询的时候再把改动下沉到对应的子节点。如果只是更新一个玩家的变化的话比较方便，直接将原来的key-1，新的key&#43;1，需要两次查询修改操作，复杂度O(logN)。
线段树还有一个应用场景是求区间的最值，比如当前有8个网关，每个网关上连接的客户端不同，要求当前连接数最少的客户端。每个节点上需要存储这个节点的区间内连接数最少的网关的id和连接数，然后层层往上比较合并，根节点的是当前最少连接数的网关。当这个网关连接数增加的时候，需要更新对应的最小值，从根节点往下依次更新和比较，主要是一次查询&#43;一次向上更新到根节点，时间和层数有关，复杂度是O(logN)
树状数组 具体介绍可以看这里：OI WIKI 树状数组 比起线段树，树状数组是代码比较简单，但是思路更复杂一点，核心是使用lowbit方法来算出树中每个节点的范围，比如要看88号节点的管理范围：
括号后面是进制 88(10)=1011000(2) lowbit(88) = 8(10) = 1000(2) 所以88号节点管理的范围为8，即80~88 树状数组的一个特点是每一层节点是二进制表示中1和0的数量不一样，比如有8个节点，8(10)=1000(2),二进制有4位。它下一层有三个孩子4、6、7，4(10)=100(2),6(10)=110(2),7(10)=111(2),二进制表示都是3位，三个孩子的管理范围不重合，且4的二进制表示中有1个1，6的二进制表示中有2个1，7的二进制表示中有3个1，很有规律，而把这些串起来的方法就是lowbit：
1. x-lowbit(x): 同一层节点之间范围井水不犯河水，用x-lowbit(x)把自己的最低位1减掉可以横向跳到同一层相邻的比较小的节点，比如7-lowbit(7)=6, 6-lowbit(6)=4。所以区间求和(1~N)的时候可以用x-lowbit(x)来跳转节点并把节点值都加起来。如果区间不是从1开始的，比如是(M~N)，可以用sum(1~N)-sum(1~M)求得。 2. x&#43;lowbit(x): 孩子节点用x&#43;lowbit(x)等于父节点，所以单点修改的时候可以用x&#43;lowbit(x)从子节点开始不断向上修改父结点的值，加上修改的数据。 和线段树比起来，树状数组的代码更简洁，因为需要保存的中间状态更少，因为通过比较巧妙的结构和lowbit进行状态转移。但是也正是因为如此，树状数组这个结构更类似于知识点一样的结构，记得就记得，不记得的话也不好想起来，不像线段树原理比较简单清楚，知道大概的原理就能直接写。而且树状数组本质是维护前缀和，所以它的扩展性是不够的，不能用来处理最大/最小值，因为没有足够的区间信息。
可以说树状数组能做的事情其实是线段树的一个子集，大多数情况下使用树状数组真的只是因为它好写并且常数小而已。然而zkw线段树(https://zhuanlan.zhihu.com/p/29876526)可以抹掉这个问题，zkw线段树省去了自顶向下查找的过程，而是直接开成满二叉树，所以比N大的最小的2^k就是第一个叶子节点。代码很短也很好理解。  统计二叉树 统计二叉树的叶子节点上保存了以当前节点为根的子树的节点总数。插入删除时，只需要把路径上的每个节点保存的节点数量加减1即可。基于这个特性，它可以支持这样的操作：
 查找第N大的节点。从根节点开始向下找，当前节点值大于N则在左子树里面找，如果N大于左子树的值，则N减去左子树的值，然后再在右子树中找，等于则就是本节点。 查找某个节点的排名。从该节点往上，如果是右节点就加上左节点的节点值，一直到根节点。  既然是二叉树，为了性能就需要保持树是平衡的，可以考虑各种平衡树的姿势(有的语言自带平衡树的实现，比如cpp里stl的map和set就是红黑树实现的)，在其基础上在节点中加上统计树的特性就可以了。">
<meta itemprop="datePublished" content="2020-04-12T14:15:23&#43;08:00" />
<meta itemprop="dateModified" content="2020-04-12T14:15:23&#43;08:00" />
<meta itemprop="wordCount" content="55">
<meta itemprop="image" content="/"/>



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="/"/>

<meta name="twitter:title" content="排行榜的数据结构和分析"/>
<meta name="twitter:description" content="在大量级的情况下，排行榜利用数据库(redis/mysql等)提供的排序功能比较不好处理，需要手动采用内存排序，排序的数据结构和算法需要谨慎选择，以在节约内存的情况下达到高性能的目的。
  e.g: mysql实时排行，处理单个请求时，百万数据需要2s、千万数据需要1min左右，当存在多个并发请求时效率很难接受。
 前XXX名排行榜服务(TopN) 特点：
 读多写少 全量拉取 一般需要显示的前XXX名比较小，而且是提前定好限制的，比如前100名  方案：
 显示的排名比较少的情况下（前100、前1000等），可以简单地维护一个集合，在查询的时候逻辑做一遍排序；也可以维护一个有序的数据结构，在每次数据变化时去触发排序。对于大批量的查询请求，可以在不同节点做缓存，设置过期时间来定时拉取数据，查询时只返回缓存中的数据。 排名数量级比较大的情况下（10w、百万、亿级别等），需要考虑特定的排序数据结构，比如bst。  数据排名服务(“我”的排名) 问题：有M（M=100万）个人分数在0~N（N=100万）之间，分数变化比较频繁，要求找出分数为X的玩家的排名。  排序数据在实际情况下是离散的、有限的，可以映射到一定的范围内，最简单的是把[X&#43;1,N]的分数段的玩家数量相加，复杂度为O(M)。为了更快地求出某个玩家的排名，可以使用的有桶排序、线段树、统计树等数据结构。如果数据量比较小的话也可以采用redis的zset。
桶排序 比如统计学生分数，满分120分，使用两层桶排序，第一层桶从0到119编号：0号桶统计0分的学生人数、1号桶统计1分的学生人数、2号桶统计2分的学生人数&hellip;第二层桶从0到19编号，每个桶统计第一层里的6个桶的总人数，比如第二层的0号桶统计第一层的0号桶到5号桶的总人数，第二层的1号桶统计第一层的6号桶到11号桶的总人数&hellip;当我们查询65分的人的排名时，如果从第一层开始我们就要从119号桶加到66号桶，但是我们可以先用第二层桶的数据，第二层桶（119-65）/6=9 也就是第二层10~19号桶的数据相加，如果是要求考63分的学生的排名，那除了第二层10~19号桶，还要加上第一层的64~65号桶的数据。如果区间比较大，比如满分是1000分或者10000分，可以考虑多加几层桶来做索引，最后实际形成的是一个树形结构。
线段树 具体介绍可以看这里：OI WIKI 线段树。其实很简单，二叉搜索树的每个节点的值都是一个固定的数，线段树的每个节点都表示的是一个范围，父节点的范围等于左右子节点的范围连接起来。比如左孩子的是[0, 3],右孩子的是[4, 5], 那么父节点的应该是[0, 5]. 线段树的第一个应用场景是连续区间求和。线段树的查询比较简单，如果要查询的范围等于某一个节点的范围，直接返回这个节点的值，如果不等于则需要进行区间结点的拆分，将几个子区间的节点值加起来。但是当数据有更新的时候，不能把所有对应区间的节点都遍历和修改，只能用懒标记，就是把改动存在父节点，之后再查询的时候再把改动下沉到对应的子节点。如果只是更新一个玩家的变化的话比较方便，直接将原来的key-1，新的key&#43;1，需要两次查询修改操作，复杂度O(logN)。
线段树还有一个应用场景是求区间的最值，比如当前有8个网关，每个网关上连接的客户端不同，要求当前连接数最少的客户端。每个节点上需要存储这个节点的区间内连接数最少的网关的id和连接数，然后层层往上比较合并，根节点的是当前最少连接数的网关。当这个网关连接数增加的时候，需要更新对应的最小值，从根节点往下依次更新和比较，主要是一次查询&#43;一次向上更新到根节点，时间和层数有关，复杂度是O(logN)
树状数组 具体介绍可以看这里：OI WIKI 树状数组 比起线段树，树状数组是代码比较简单，但是思路更复杂一点，核心是使用lowbit方法来算出树中每个节点的范围，比如要看88号节点的管理范围：
括号后面是进制 88(10)=1011000(2) lowbit(88) = 8(10) = 1000(2) 所以88号节点管理的范围为8，即80~88 树状数组的一个特点是每一层节点是二进制表示中1和0的数量不一样，比如有8个节点，8(10)=1000(2),二进制有4位。它下一层有三个孩子4、6、7，4(10)=100(2),6(10)=110(2),7(10)=111(2),二进制表示都是3位，三个孩子的管理范围不重合，且4的二进制表示中有1个1，6的二进制表示中有2个1，7的二进制表示中有3个1，很有规律，而把这些串起来的方法就是lowbit：
1. x-lowbit(x): 同一层节点之间范围井水不犯河水，用x-lowbit(x)把自己的最低位1减掉可以横向跳到同一层相邻的比较小的节点，比如7-lowbit(7)=6, 6-lowbit(6)=4。所以区间求和(1~N)的时候可以用x-lowbit(x)来跳转节点并把节点值都加起来。如果区间不是从1开始的，比如是(M~N)，可以用sum(1~N)-sum(1~M)求得。 2. x&#43;lowbit(x): 孩子节点用x&#43;lowbit(x)等于父节点，所以单点修改的时候可以用x&#43;lowbit(x)从子节点开始不断向上修改父结点的值，加上修改的数据。 和线段树比起来，树状数组的代码更简洁，因为需要保存的中间状态更少，因为通过比较巧妙的结构和lowbit进行状态转移。但是也正是因为如此，树状数组这个结构更类似于知识点一样的结构，记得就记得，不记得的话也不好想起来，不像线段树原理比较简单清楚，知道大概的原理就能直接写。而且树状数组本质是维护前缀和，所以它的扩展性是不够的，不能用来处理最大/最小值，因为没有足够的区间信息。
可以说树状数组能做的事情其实是线段树的一个子集，大多数情况下使用树状数组真的只是因为它好写并且常数小而已。然而zkw线段树(https://zhuanlan.zhihu.com/p/29876526)可以抹掉这个问题，zkw线段树省去了自顶向下查找的过程，而是直接开成满二叉树，所以比N大的最小的2^k就是第一个叶子节点。代码很短也很好理解。  统计二叉树 统计二叉树的叶子节点上保存了以当前节点为根的子树的节点总数。插入删除时，只需要把路径上的每个节点保存的节点数量加减1即可。基于这个特性，它可以支持这样的操作：
 查找第N大的节点。从根节点开始向下找，当前节点值大于N则在左子树里面找，如果N大于左子树的值，则N减去左子树的值，然后再在右子树中找，等于则就是本节点。 查找某个节点的排名。从该节点往上，如果是右节点就加上左节点的节点值，一直到根节点。  既然是二叉树，为了性能就需要保持树是平衡的，可以考虑各种平衡树的姿势(有的语言自带平衡树的实现，比如cpp里stl的map和set就是红黑树实现的)，在其基础上在节点中加上统计树的特性就可以了。"/>





    <meta property="article:published_time" content="2020-04-12 14:15:23 &#43;0800 CST" />








    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$cd /home/</span>
            <span class="logo__cursor" style=""></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/post">Posts</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="/post/ranking_data_structure/">排行榜的数据结构和分析</a></h2>

            

            <div class="post-content">
                <blockquote>
<p>在大量级的情况下，排行榜利用数据库(redis/mysql等)提供的排序功能比较不好处理，需要手动采用内存排序，排序的数据结构和算法需要谨慎选择，以在节约内存的情况下达到高性能的目的。</p>
</blockquote>
<blockquote>
<p>e.g: mysql实时排行，处理单个请求时，百万数据需要2s、千万数据需要1min左右，当存在多个并发请求时效率很难接受。</p>
</blockquote>
<h2 id="前xxx名排行榜服务topn">前XXX名排行榜服务(TopN)</h2>
<p>特点：</p>
<ol>
<li>读多写少</li>
<li>全量拉取</li>
<li>一般需要显示的前XXX名比较小，而且是提前定好限制的，比如前100名</li>
</ol>
<p>方案：</p>
<ul>
<li>显示的排名比较少的情况下（前100、前1000等），可以简单地维护一个集合，在查询的时候逻辑做一遍排序；也可以维护一个有序的数据结构，在每次数据变化时去触发排序。对于大批量的查询请求，可以在不同节点做缓存，设置过期时间来定时拉取数据，查询时只返回缓存中的数据。</li>
<li>排名数量级比较大的情况下（10w、百万、亿级别等），需要考虑特定的排序数据结构，比如bst。</li>
</ul>
<h2 id="数据排名服务我的排名">数据排名服务(“我”的排名)</h2>
<pre><code>问题：有M（M=100万）个人分数在0~N（N=100万）之间，分数变化比较频繁，要求找出分数为X的玩家的排名。
</code></pre>
<p>排序数据在实际情况下是离散的、有限的，可以映射到一定的范围内，最简单的是把[X+1,N]的分数段的玩家数量相加，复杂度为O(M)。为了更快地求出某个玩家的排名，可以使用的有桶排序、线段树、统计树等数据结构。如果数据量比较小的话也可以采用redis的zset。</p>
<h3 id="桶排序">桶排序</h3>
<p>比如统计学生分数，满分120分，使用两层桶排序，第一层桶从0到119编号：0号桶统计0分的学生人数、1号桶统计1分的学生人数、2号桶统计2分的学生人数&hellip;第二层桶从0到19编号，每个桶统计第一层里的6个桶的总人数，比如第二层的0号桶统计第一层的0号桶到5号桶的总人数，第二层的1号桶统计第一层的6号桶到11号桶的总人数&hellip;当我们查询65分的人的排名时，如果从第一层开始我们就要从119号桶加到66号桶，但是我们可以先用第二层桶的数据，第二层桶（119-65）/6=9 也就是第二层10~19号桶的数据相加，如果是要求考63分的学生的排名，那除了第二层10~19号桶，还要加上第一层的64~65号桶的数据。如果区间比较大，比如满分是1000分或者10000分，可以考虑多加几层桶来做索引，最后实际形成的是一个树形结构。</p>
<h3 id="线段树">线段树</h3>
<p>具体介绍可以看这里：<a href="https://oi-wiki.org/ds/seg/">OI WIKI 线段树</a>。其实很简单，二叉搜索树的每个节点的值都是一个固定的数，线段树的每个节点都表示的是一个范围，父节点的范围等于左右子节点的范围连接起来。比如左孩子的是[0, 3],右孩子的是[4, 5], 那么父节点的应该是[0, 5].
线段树的第一个应用场景是连续区间求和。线段树的查询比较简单，如果要查询的范围等于某一个节点的范围，直接返回这个节点的值，如果不等于则需要进行区间结点的拆分，将几个子区间的节点值加起来。但是当数据有更新的时候，不能把所有对应区间的节点都遍历和修改，只能用懒标记，就是把改动存在父节点，之后再查询的时候再把改动下沉到对应的子节点。如果只是更新一个玩家的变化的话比较方便，直接将原来的key-1，新的key+1，需要两次查询修改操作，复杂度O(logN)。</p>
<p>线段树还有一个应用场景是求区间的最值，比如当前有8个网关，每个网关上连接的客户端不同，要求当前连接数最少的客户端。每个节点上需要存储这个节点的区间内连接数最少的网关的id和连接数，然后层层往上比较合并，根节点的是当前最少连接数的网关。当这个网关连接数增加的时候，需要更新对应的最小值，从根节点往下依次更新和比较，主要是一次查询+一次向上更新到根节点，时间和层数有关，复杂度是O(logN)</p>
<h3 id="树状数组">树状数组</h3>
<p>具体介绍可以看这里：<a href="https://oi-wiki.org/ds/fenwick/">OI WIKI 树状数组</a>
比起线段树，树状数组是代码比较简单，但是思路更复杂一点，核心是使用lowbit方法来算出树中每个节点的范围，比如要看88号节点的管理范围：</p>
<pre><code>括号后面是进制
88(10)=1011000(2)
lowbit(88) = 8(10) = 1000(2)
所以88号节点管理的范围为8，即80~88
</code></pre><p>树状数组的一个特点是每一层节点是二进制表示中1和0的数量不一样，比如有8个节点，8(10)=1000(2),二进制有4位。它下一层有三个孩子4、6、7，4(10)=100(2),6(10)=110(2),7(10)=111(2),二进制表示都是3位，三个孩子的管理范围不重合，且4的二进制表示中有1个1，6的二进制表示中有2个1，7的二进制表示中有3个1，很有规律，而把这些串起来的方法就是lowbit：</p>
<pre><code>1. x-lowbit(x): 同一层节点之间范围井水不犯河水，用x-lowbit(x)把自己的最低位1减掉可以横向跳到同一层相邻的比较小的节点，比如7-lowbit(7)=6, 6-lowbit(6)=4。所以区间求和(1~N)的时候可以用x-lowbit(x)来跳转节点并把节点值都加起来。如果区间不是从1开始的，比如是(M~N)，可以用sum(1~N)-sum(1~M)求得。

2. x+lowbit(x): 孩子节点用x+lowbit(x)等于父节点，所以单点修改的时候可以用x+lowbit(x)从子节点开始不断向上修改父结点的值，加上修改的数据。
</code></pre><p>和线段树比起来，树状数组的代码更简洁，因为需要保存的中间状态更少，因为通过比较巧妙的结构和lowbit进行状态转移。但是也正是因为如此，树状数组这个结构更类似于知识点一样的结构，记得就记得，不记得的话也不好想起来，不像线段树原理比较简单清楚，知道大概的原理就能直接写。而且树状数组本质是维护前缀和，所以它的扩展性是不够的，不能用来处理最大/最小值，因为没有足够的区间信息。</p>
<pre><code>可以说树状数组能做的事情其实是线段树的一个子集，大多数情况下使用树状数组真的只是因为它好写并且常数小而已。然而zkw线段树(https://zhuanlan.zhihu.com/p/29876526)可以抹掉这个问题，zkw线段树省去了自顶向下查找的过程，而是直接开成满二叉树，所以比N大的最小的2^k就是第一个叶子节点。代码很短也很好理解。
</code></pre>
<h3 id="统计二叉树">统计二叉树</h3>
<p>统计二叉树的叶子节点上保存了以当前节点为根的子树的节点总数。插入删除时，只需要把路径上的每个节点保存的节点数量加减1即可。基于这个特性，它可以支持这样的操作：</p>
<ol>
<li>查找第N大的节点。从根节点开始向下找，当前节点值大于N则在左子树里面找，如果N大于左子树的值，则N减去左子树的值，然后再在右子树中找，等于则就是本节点。</li>
<li>查找某个节点的排名。从该节点往上，如果是右节点就加上左节点的节点值，一直到根节点。</li>
</ol>
<p>既然是二叉树，为了性能就需要保持树是平衡的，可以考虑各种平衡树的姿势(有的语言自带平衡树的实现，比如cpp里stl的map和set就是红黑树实现的)，在其基础上在节点中加上统计树的特性就可以了。</p>

            </div>
        </article>

        <hr />

        <div class="post-info">
  			</div>

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2020</span>
            
            <span>Bittree. All rights reserved.</span>
            <span> <a href="/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">rhazdon</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="/bundle.min.2d5469329143160ae2456a69c3c76dc2d0a3b212b46afe291a51bd68650ed6f8697e001dab54f1c272c77ce08092a8c55e5bb4314e0ee334aab4b927ec896638.js" integrity="sha512-LVRpMpFDFgriRWppw8dtwtCjshK0av4pGlG9aGUO1vhpfgAdq1TxwnLHfOCAkqjFXlu0MU4O4zSqtLkn7IlmOA=="></script>



    </body>
</html>
